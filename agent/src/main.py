from openai import OpenAI
from dotenv import load_dotenv
import os
import rzresolution

load_dotenv()

BASE_URL = os.getenv('BASE_URL')
DEEPSEEK_API_KEY = os.getenv('DEEPSEEK_API_KEY')
MODEL = os.getenv('MODEL')

client = OpenAI(api_key=DEEPSEEK_API_KEY, base_url=BASE_URL)

agent_prompt = (
    "Ты умный математик, работающий в области математической логики. "
    "Тебе дают текстовую задачу на русском языке. "
    "Тебе нужно её понять и преобразовать в набор посылок логики предикатов. "

    "Используй предикаты типа H(x), L(x, y) и другие в таком же стиле в зависимости от задачи. "
    "Причем называй константы, переменные одной буквой в нижнем регистре, а предикаты называй только вверхнем регистре. "
    "Учитывай, что первая половина английского алфавита до буквы n не включая - это константы, а оставшаяся после n включая n - это переменные. "
    "Используй кванторы forall, exists. "
    "Логические операторы: implies (импликация), not (отрицание), and (конъюнкция), or (дизъюнкция). "

    "ВНИМАНИЕ: Не используй математические символы `∀`, `∃`, `→`, `¬`, `∧`, `∨`. Всегда используй только слова: `forall`, `exists`, `implies`, `not`, `and`, `or`."

    "Используй строго префиксную нотацию (оператор в начале). Например: `(implies (P x) (Q x))`, а не `(P(x) → Q(x))`."
    "Аргументы в предикатах пиши без пробела, например `(H x)`, а не `(H (x))`."

    "Выведи ТОЛЬКО посылки, где каждая посылка с новой строки, без нумерации и без любых других символов. "
    "НИКОГДА не добавляй слова 'Ответ:', 'Решение:' или любые другие пояснения перед посылками. "
    "Вывод должен начинаться СРАЗУ с первой посылки, без пустых строк в начале."
    "Если ты добавишь любой текст кроме самих посылок, это будет ошибкой. "
    
    "Если перед посылкой написано ДОКАЖИ, то нужно написать отрицание этой посылки, чтобы доказывать от противного. "

    "Пример КОРРЕКТНОГО вывода:\n"
    "(forall x (implies (H x) (M x)))\n"
    "(Human s)\n"
    "(not (M s))\n"
    "\n"
    "Пример НЕКОРРЕКТНОГО вывода:\n"
    "Ответ:\n"
    "(forall x (implies (Human x) (Mortal x)))\n"
    "(Human Socrates)\n"
    "(not (Mortal Socrates))"
)

statement1 = "Все люди - смертны. Сократ - человек. Докажи, что Сократ - смертен."
statement2 = "Существуют пациенты, которые любят абсолютно всех докторов. Любой пациент не любит любого знахаря. Докажи, что ни один доктор не является знахарем."
statement3 = "Если идет дождь, то улица мокрая. Улица не мокрая. Докажи, что дождь не идет."
statement4 = "Убийца никогда не носит черное. Все, кто был на вечеринке, носили черное. Джон был на вечеринке. Докажите, что Джон не убийца."

def interpret_premises(premises):
    """
    Интерпретирует логические посылки через ИИ
    """
    interpretation_prompt = """
Ты - эксперт по математической логике и лингвистическому анализу. Твоя задача - интерпретировать формальные логические посылки на естественный русский язык.

ПРАВИЛА ИНТЕРПРЕТАЦИИ:
1. Преобразуй каждую посылку в понятное утверждение на русском языке
2. Сохрани логическую структуру (кванторы, связки, отрицания)
3. Если предикаты имеют очевидную семантику (H, M, P, Q и т.д.), дай им содержательные имена
4. Если семантика неочевидна, используй нейтральные термины ("обладает свойством P", "находится в отношении R с")
5. Для неинтерпретируемых посылок (технических артефактов, пустых клауз) верни "НЕИНТЕРПРЕТИРУЕМАЯ ПОСЫЛКА"

ФОРМАТ ОТВЕТА:
- Только список интерпретаций, по одной на строку
- Без нумерации, без дополнительных комментариев
- Каждая интерпретация должна начинаться с символа "•"

КРИТЕРИИ НЕИНТЕРПРЕТИРУЕМОСТИ:
□ (пустая клауза) - противоречие
Посылки только с техническими символами
Посылки без содержательной семантики

Теперь интерпретируй эти посылки:
"""

    premises_text = "\n".join(premises)
    
    response = client.chat.completions.create(
        model=MODEL,
        messages=[
            {"role": "system", "content": interpretation_prompt},
            {"role": "user", "content": premises_text}
        ],
        stream=False
    )
    
    return response.choices[0].message.content

def main():
    response = client.chat.completions.create(model=MODEL,
                                              messages=[
                                                  {"role": "system", "content": agent_prompt},
                                                  {"role": "user", "content": statement1}],
                                              stream=False)

    print(response.choices[0].message.content)
    
    premises = response.choices[0].message.content.split("\n")

    interpretation = interpret_premises(premises)
    print(interpretation)
    
    res, history = rzresolution.make_resolution(premises)
    print(res)
    print(history)

if __name__ == "__main__":
    main()
